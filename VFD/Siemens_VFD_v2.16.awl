FUNCTION_BLOCK FB 98
TITLE =Siemens VFD Micro Master 4 & Sinamics
KNOW_HOW_PROTECT
//VFD control for Siemens Simovert Micro Master 4 and Sinamics drives.
//
//Micro Master 4: PPo 1 mode:        4 * PKW + 2 * PZD
//Sinamics:       Telegram 353 mode: 4 * PIV + 2 * PZD
AUTHOR : STP
FAMILY : DRIVE
NAME : MM_SIN
VERSION : 3.0
CODE_VERSION1

VAR_INPUT
  ADDRESS : INT  := 300;	//Peripheral address of the drive
  Run : BOOL ;	//Control system run permissive (OFF1)
  Coast : BOOL ;	//0=RFG stop; 1=coast stop (=remove pulses immediately on stop)
  RESET : BOOL ;	//Reset errors
  Setpoint : INT ;	//Speed setpoint [-199% ... + 199%] 
END_VAR
VAR_OUTPUT
  Speed : INT ;	//Actual relative motor speed as %
  Current : REAL ;	//Actual motor current
  Torque : REAL ;	//Actual motor torque
  RPM : REAL ;	//Actual motor RPM
  Frequency : REAL ;	//Actual motor Frequency
  Running : BOOL ;	//Drive running either left or right
  Warning : BOOL ;	//Drive warning is active
  Fault : BOOL ;	//Drive fault is active
  Diag_code : DINT ;	//Current diagnostics code
END_VAR
VAR
  Job : STRUCT 	
   RW_Request_1 : BOOL ;	//r0027: actual motor current
   RW_Request_2 : BOOL ;	//r0080: actual motor torque
   RW_Request_3 : BOOL ;	//Custom R/W parameters
   W_Pulses_enable : BOOL ;	//Internal: Set "Pulses enable" to 0
   W_Store_mode : BOOL ;	//Internal: Store mode (RAM/EEPROM)
   RW_Commissioning : BOOL ;	//Internal: Start quick commissioning
   RW_Factory_setting : BOOL ;	//Internal: Factory setting
   RW_Motor_identification : BOOL ;	//Internal: Choose motor data identification
   W_End_Quick_comm : BOOL ;	//Internal: end of quick commissioning 
   RW_RAM_to_EEPROM : BOOL ;	//Internal: Name can be changed
   R_End_QC : BOOL ;	//Internal: Observe if the quick commissioning ends
   RW_Drive_data : BOOL ;	//Internal: Name can be changed
   R_Last_warnings : BOOL ;	//Display: Read last warnings
   R_Last_faults : BOOL ;	//Display: Read last fault messages
   R_Last_fault_values : BOOL ;	//Display: Read fault value (service information) 
   R_Firmware_version : BOOL ;	//Display: Firm / Product type / Version / Date
   R_Request_17 : BOOL ;	//r0022: actual motor RPM
   R_Request_18 : BOOL ;	//P0311: rated motor RPM
   R_Request_19 : BOOL ;	//P0305: rated motor current
   R_Request_20 : BOOL ;	//P2000: reference speed
   R_Request_21 : BOOL ;	//r0070: actual DC link voltage
   R_Request_22 : BOOL ;	//P0305: rated motor frequency
   R_Request_23 : BOOL ;	//P0820: DDS bit 0 source
   R_Request_24 : BOOL ;	//P0821: DDS bit 1 source
   R_Request_25 : BOOL ;	//r0051/0837: Active Drive Data Set
   R_Request_26 : BOOL ;	//r0024: actual motor frequency
   R_Request_27 : BOOL ;	//Free
   R_Request_28 : BOOL ;	//Free
   R_Request_29 : BOOL ;	//Free
   R_Request_30 : BOOL ;	//Free
   R_Request_31 : BOOL ;	//Free
   R_Request_32 : BOOL ;	//r0053: ZSW 2
  END_STRUCT ;	
  Data_fault : STRUCT 	
   JOB : STRUCT 	
    RW_Request_1 : BOOL ;	//r0027: actual motor current
    RW_Request_2 : BOOL ;	//r0080: actual motor torque
    RW_Request_3 : BOOL ;	//Custom R/W parameters
    W_Pulses_enable : BOOL ;	//Intern: Impulsfreigabe auf 0 setzen
    W_Store_mode : BOOL ;	//Intern: Speicher (RAM/EEPROM)
    RW_Commissioning : BOOL ;	//Intern: Schnellinbetriebnahme starten
    RW_Factory_setting : BOOL ;	//Intern: Werkseinstellung herstellen
    RW_Motor_identification : BOOL ;	//Intern: Anwahl Motordaten-Identifikation
    W_End_quick_comm : BOOL ;	//Intern: Ende der Schnellinbetriebnahme 
    RW_RAM_to_EEPROM : BOOL ;	//Intern: Name kann geändert werden
    R_End_QC : BOOL ;	//Intern: Überwachung ob Schnellinbetriebnahme beendet
    RW_Drive_data : BOOL ;	//Intern: Name kann geändert werden
    R_Last_warnings : BOOL ;	//Anzeige: Letzte Warnungen lesen
    R_Last_faults : BOOL ;	//Anzeige: Letzte Fehlermeldungen lesen
    R_Last_fault_values : BOOL ;	//Anzeige: Fehlerwert  (Serviceinformation) lesen 
    R_Firmware_version : BOOL ;	//Anzeige: Firma / Produkttyp / Version / Datum
    R_Request_17 : BOOL ;	//r0022: actual motor RPM
    R_Request_18 : BOOL ;	//P0311: rated motor RPM
    R_Request_19 : BOOL ;	//P0305: rated motor current
    R_Request_20 : BOOL ;	//P2000: reference speed
    R_Request_21 : BOOL ;	//r0070: actual DC link voltage
    R_Request_22 : BOOL ;	//r0310: actual motor frequency
    R_Request_23 : BOOL ;	//P0820: Source for DDS bit 0
    R_Request_24 : BOOL ;	//P0821: Source for DDS bit 1
    R_Request_25 : BOOL ;	//r0051: Actual DDS
    R_Request_26 : BOOL ;	//Free
    R_Request_27 : BOOL ;	//Free
    R_Request_28 : BOOL ;	//Free
    R_Request_29 : BOOL ;	//Free
    R_Request_30 : BOOL ;	//Free
    R_Request_31 : BOOL ;	//Free
    R_Request_32 : BOOL ;	//r0053: ZSW 2
   END_STRUCT ;	
   Nr : INT ;	//Fault Nr
   DP_Add_info : WORD ;	//Fault message from SFC 14/15
   Request_Nr : INT ;	//[1..16] points at the faulty request
   Index : INT ;	//Request index 
   Parameter_Nr : INT ;	//Parameter_Nr from the faulty request
   Fault_Commissioning : INT ;	
  END_STRUCT ;	
  Job_1 : STRUCT 	//r0027: actual motor current
   Parameter_Nr : INT  := 27;	//r0027 Act. filtered output current
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Motor_current : REAL ;	
   Value_2 : DINT ;	
   Value_3 : DINT ;	
  END_STRUCT ;	
  Job_2 : STRUCT 	//r0080: actual motor torque
   Parameter_Nr : INT  := 80;	//r0080: Act. torque
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Motor_torque : REAL ;	
   Value_2 : DINT ;	
   Value_3 : DINT ;	
  END_STRUCT ;	
  Job_3 : STRUCT 	//Custom R/W parameters
   Parameter_Nr : INT ;	//Parameter Nr from parameter list
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE ;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT ;	
   Value_2 : DINT ;	
   Value_3 : DINT ;	
  END_STRUCT ;	
  Job_4 : STRUCT 	//P0852: Pulses enable
   Parameter_Nr : INT  := 852;	//P0852: BI: Pulses enable
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#3;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT ;	//0: Fest set to 0
  END_STRUCT ;	
  Job_5 : STRUCT 	//r0014: Store mode
   Parameter_Nr : INT  := 14;	//Store mode (RAM/EEPROM)
   Index : INT  := 2;	//2: Profibus / CB
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT ;	//0:Keep all the parameters as it was defined in the request 
  END_STRUCT ;	
  Job_6 : STRUCT 	//r0010: Quick commissioning parameters
   Parameter_Nr : INT  := 10;	//Quick commissioning parameters
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT  := L#1;	//1: Quick commissioning, 30: Factory setting
  END_STRUCT ;	
  Job_7 : STRUCT 	//P0970: RESET to factory setting
   Parameter_Nr : INT  := 970;	//RESET to factory setting
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT  := L#1;	
  END_STRUCT ;	
  Job_8 : STRUCT 	//P1910: Choose motor data identification
   Parameter_Nr : INT  := 1910;	//Choose motor data identification
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT ;	
  END_STRUCT ;	
  Job_9 : STRUCT 	//P2300: End of quick commissioning
   Parameter_Nr : INT  := 3900;	//End of quick commissioning / Start the calculation of motor data
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT  := L#3;	//3: Motor and regulator calculation
  END_STRUCT ;	
  Job_10 : STRUCT 	//P0971: Copy RAM to EEPROM
   Parameter_Nr : INT  := 971;	//Copy values from RAM to EEPROM
   Index : INT ;	
   Identifier : BYTE  := B#16#2;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT  := L#1;	//0: Write all the data as defined  1: Write all values to EEPROM
  END_STRUCT ;	
  Job_11 : STRUCT 	//P3900: End QC & stop motor ID
   Parameter_Nr : INT  := 3900;	//End of quick commissioning / Stop observe motor data calculation
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DINT ;	
  END_STRUCT ;	
  Job_12 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#3;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_13 : STRUCT 	//Last warnings
   Parameter_Nr : INT  := 2110;	//Last warnings (drive type dependent)
   Index : INT  := 3;	//Subparameter Nr
   Identifier : BYTE  := B#16#11;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Last_warning_1 : DINT ;	//Last warning        Warning 1
   Last_warning_2 : DINT ;	//Last warning        Warning 1
   Old_1_warning_1 : DINT ;	//Last warning - 1    Warning 1
   Old_1_warning_2 : DINT ;	//Last warning - 1    Warning 2
  END_STRUCT ;	
  Job_14 : STRUCT 	//Last faults
   Parameter_Nr : INT  := 947;	//Last fault messages
   Index : INT  := 7;	//Subparameter Nr
   Identifier : BYTE  := B#16#11;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Last_fault_1 : DINT ;	//Last fault         Fault 1
   Last_fault_2 : DINT ;	//Last fault         Fault 2
   Old_1_fault_1 : DINT ;	//Last fault - 1     Fault 1
   Old_1_fault_2 : DINT ;	//Last fault - 1     Fault 2
   Old_2_fault_1 : DINT ;	//Last fault - 2     Fault 1
   Old_2_fault_2 : DINT ;	//Last fault - 2     Fault 2
   Old_3_fault_1 : DINT ;	//Last fault - 3     Fault 1
   Old_3_fault_2 : DINT ;	//Last fault - 3     Fault 2
  END_STRUCT ;	
  Job_15 : STRUCT 	//r0949: Fault value
   Parameter_Nr : INT  := 949;	//Fault value  (service information)
   Index : INT  := 7;	//Subparameter Nr
   Identifier : BYTE  := B#16#11;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Last_fault_values_1 : DINT ;	//Last fault         Fault value 1
   Last_fault_values_2 : DINT ;	//Last fault         Fault value 2
   Old_1_fault_values_1 : DINT ;	//Last fault - 1     Fault value 1
   Old_1_fault_values_2 : DINT ;	//Last fault - 1     Fault value 2
   Old_2_fault_values_1 : DINT ;	//Last fault - 2     Fault value 1
   Old_2_fault_values_2 : DINT ;	//Last fault - 2     Fault value 2
   Old_3_fault_values_1 : DINT ;	//Last fault - 3     Fault value 1
   Old_3_fault_values_2 : DINT ;	//Last fault - 3     Fault value 2
  END_STRUCT ;	
  Job_16 : STRUCT 	//r0964: Firmware
   Parameter_Nr : INT  := 964;	//Read firmware version
   Index : INT  := 4;	//Subparameter Nr
   Identifier : BYTE  := B#16#11;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Firm : DINT ;	//42: Siemens
   Type_1 : DINT ;	//Drive type
   Firmware_version : DINT ;	//Firmware version
   Date_year : DINT ;	//Date: year
   Date_day_month : DINT ;	//Date: day/month
  END_STRUCT ;	
  Job_17 : STRUCT 	//r0022: actual motor RPM
   Parameter_Nr : INT  := 22;	//Actual motor RPM
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Motor_RPM : REAL ;	
  END_STRUCT ;	
  Job_18 : STRUCT 	//P0311: rated motor RPM
   Parameter_Nr : INT  := 311;	//Rated motor RPM
   Index : INT ;	//Subparameter Nr (overwritten)
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Rated_motor_RPM : DWORD ;	
  END_STRUCT ;	
  Job_19 : STRUCT 	//P0305: rated motor current
   Parameter_Nr : INT  := 305;	//Rated motor current
   Index : INT ;	//Subparameter Nr (overwritten)
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Rated_motor_current : REAL ;	
  END_STRUCT ;	
  Job_20 : STRUCT 	//P2000: reference speed
   Parameter_Nr : INT  := 2000;	//Reference speed
   Index : INT ;	//Subparameter Nr (overwritten)
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Reference_speed : REAL ;	
  END_STRUCT ;	
  Job_21 : STRUCT 	//r0026: actual DC link voltage
   Parameter_Nr : INT  := 70;	//Actual DC link voltage
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   DC_link_volt : REAL ;	
  END_STRUCT ;	
  Job_22 : STRUCT 	//P0305: rated motor frequency
   Parameter_Nr : INT  := 310;	//Rated motor frequency
   Index : INT ;	//Subparameter Nr (overwritten)
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Rated_motor_frequency : REAL ;	
  END_STRUCT ;	
  Job_23 : STRUCT 	//P0820: DDS 0 source
   Parameter_Nr : INT  := 820;	//P0820: DDS bit 0 source
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_24 : STRUCT 	//P0821: DDS 1 source
   Parameter_Nr : INT  := 821;	//P0821: DDS bit 1 source
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_25 : STRUCT 	//r0051/0837: Active Drive Data Set
   Parameter_Nr : INT  := 51;	//r0051/0837: Active Drive Data Set
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_26 : STRUCT 	//r0024: output frequency
   Parameter_Nr : INT  := 24;	//r24: CO: Act. filtered output freq. [Hz]
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Motor_frq : REAL ;	//Motor frequency
  END_STRUCT ;	
  Job_27 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_28 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_29 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_30 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_31 : STRUCT 	//Free
   Parameter_Nr : INT ;	//Free
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Value : DWORD ;	
  END_STRUCT ;	
  Job_32 : STRUCT 	//r0053: ZSW2
   Parameter_Nr : INT  := 53;	//r0053: Status word 2 ZSW2
   Index : INT ;	//Subparameter Nr
   Identifier : BYTE  := B#16#1;	//1/11:read 2/12:write to RAM 3/13:write to EEPROM
   Identifier_internal : BYTE ;	//set up automatically
   Byte0 : BYTE ;	
   Byte1 : BYTE ;	
   ZSW2 : STRUCT 	
    Bit_08 : BOOL ;	//Vdc > P2172
    Bit_09 : BOOL ;	//Ramp-up/down completed
    Bit_10 : BOOL ;	//Technology controller output at lower limit
    Bit_11 : BOOL ;	//Technology controller output at upper limit
    Bit_12 : BOOL ;	//N/U
    Bit_13 : BOOL ;	//N/U
    Bit_14 : BOOL ;	//N/U
    Bit_15 : BOOL ;	//N/U
    Bit_00 : BOOL ;	//DC braking active
    Bit_01 : BOOL ;	//n_act > P1228 (n_standstill)
    Bit_02 : BOOL ;	//n_act > P1080 (n_min)
    Bit_03 : BOOL ;	//I_act >= P2170
    Bit_04 : BOOL ;	//n_act > P2155
    Bit_05 : BOOL ;	//n_act <= P2155
    Bit_06 : BOOL ;	//n_act >= r1119 (n_ref)
    Bit_07 : BOOL ;	//Vdc <= P2172
   END_STRUCT ;	
  END_STRUCT ;	
  PCD_receive : STRUCT 	//Free
   No_set_act_val_deviation : BOOL ;	//8: 1=No Istwert/Sollwert deviation
   Control : BOOL ;	//9: 1=Master control requested
   f_reached : BOOL ;	//10: 1=Output freq/speed >= max freq/speed
   No_motor_current_limit : BOOL ;	//11: 0=Motor at current limit
   No_motor_holding_brake : BOOL ;	//12: 0=No holding brake
   No_motor_overload : BOOL ;	//13: 0=Motor overload
   Motor_runs_right : BOOL ;	//14: 0=CCW; 1=CW
   No_inverter_overload : BOOL ;	//15: 0=Inverter overload
   Drive_ready : BOOL ;	//0: 1=Ready for ON
   Drive_ready_to_run : BOOL ;	//1: 1=Ready to run
   Drive_running : BOOL ;	//2: 1=Operation enabled
   Fault : BOOL ;	//3: 1=Fault active
   OFF2_active : BOOL ;	//4: 1=OFF2 active
   OFF3_active : BOOL ;	//5: 1=OFF3 active
   ON_inhibit_active : BOOL ;	//6: 1=Starting lockout
   Warning : BOOL ;	//7: 1=Alarm is active
   Speed : INT ;	//Setpoint (0x4000 = 100% relative to P2000)
  END_STRUCT ;	
  PCD_send : STRUCT 	//Free
   JOG_right : BOOL ;	//8: 1=Jog CW
   JOG_left : BOOL ;	//9: 1=JOg CCW
   Control_from_PLC : BOOL  := TRUE;	//10: 1=DP master supplies valid setpoints
   Reverse : BOOL ;	//11: 1=Reverse rotation (CCW on positive setpoint)
   Bit12 : BOOL ;	//12: Not used
   DDS_Bit_0 : BOOL ;	//13: DDS bit 0 (was MOP up)
   DDS_Bit_1 : BOOL ;	//14: DDS bit 1 (was MOP down)
   CDS_Bit_0 : BOOL ;	//15: CDS bit 0
   OFF1 : BOOL ;	//0: 1=Set inverter 'ready to run'; 0=RFG ramp down (must transition 0->1)
   OFF2 : BOOL ;	//1: 0=Remove pulses, coast to stop
   OFF3 : BOOL ;	//2: 0=Ramp down along RFG (P1135)
   RUN_enable : BOOL  := TRUE;	//3: 1=Closed-loop control + pulses are enabled
   Operating_condition : BOOL  := TRUE;	//4: 1=Operating condition; 0=Disable RFG, drive remains on
   RFG_enable : BOOL  := TRUE;	//5: 1=Enable RFG; 0=Freeze RFG setpoint
   Setpoint_enable : BOOL  := TRUE;	//6: 0=Setpoint disabled, RFG input 0; 1=Setpoint at RFG enabled
   Fault_acknowledge : BOOL ;	//7: 1=Acknowledge faults
   Main_setpoint : INT ;	//Speed setpoint, 0x4000 = 100% (relative to P2000)
  END_STRUCT ;	
  PKW : STRUCT 	//Free
   RECEIVE : STRUCT 	
    Identifier_Nr : WORD ;	
    Index : INT ;	
    Value : DINT ;	
   END_STRUCT ;	
   SEND : STRUCT 	
    Identifier_Nr : WORD ;	
    Index : INT ;	
    Value : DINT ;	
   END_STRUCT ;	
  END_STRUCT ;	
  Intern : STRUCT 	//Free
   P_Job : DWORD ;	
   Offset_value : WORD ;	//Pointer offset
   Index_counter : INT ;	//[0..] points at subparameter in work
   Job_counter : INT ;	//Job counter [0..15] Points at job in work
   Job_P_BITS : DWORD ;	//Actual pointer
   Watch_Dog_write : INT ;	//[0..50] cycles counter
   Parameter_Nr_actual : INT ;	//actual transfered parameter
   Fault_DP_SFC14_15 : INT ;	
   Job_an : BOOL ;	
   Job_end : BOOL ;	//at the end of the end of the job 0 will be sent to DP
   DP_fault : BOOL ;	
   F_Reset_Internal : BOOL ;	
   Motor_data_identificat : BOOL ;	
   err : BOOL ;	//Fault
   Fault_DP_PCD_access : BOOL ;	
   Trans_Para : STRUCT 	
    Status : INT ;	
    Stop_fault_estimation : BOOL ;	
    Reset_data_fault_intern : BOOL ;	
    Motor_data_read_end : BOOL ;	
    P_Parameter_list : DWORD ;	
    DB_NR : INT ;	
   END_STRUCT ;	
  END_STRUCT ;	
  Enable : BOOL ;	//(OFF2 etc.)
  Drive_ready : BOOL ;	//Drive is not running but ready to run
  Drive_STOP : BOOL ;	//Drive is in standstill
  Motor_Right : BOOL ;	//Drive running right 
  Motor_Left : BOOL ;	//Drive running left
  Commission : STRUCT 	
   Enable_QC : BOOL ;	//Enable commissioning
   Motor_ID : BOOL ;	//MM4xx all motor data identification with parameter changes
   Data_transfer_running : BOOL ;	//Data transfer of the technological parameters is running
   Sat_curve : BOOL ;	//MM440 saturation curve identification with parameter changes
   IO_W_Parameters : BOOL ;	//Write parameters
   IO_R_Parameters : BOOL ;	//Read parameters
   Internal_error : BOOL ;	//Data error
   Motor_data_DB : INT  := 54;	
   Tech_data_DB : INT ;	//If 0 then follows the technological data the motor data
  END_STRUCT ;	
  Config : STRUCT 	
   Parameter_nr : INT ;	//Parameter nr to read/write
   Parameter_index : INT ;	//Parameter index to read/write
   Value_new : DWORD ;	//Value to write (DINT/FLOAT)
   Value : DWORD ;	//Value read
   Write_new : BOOL ;	//Write Value_new to drive
  END_STRUCT ;	
  DDS : STRUCT 	
   Nr : INT ;	//Desired Drive Data Set [0..2]
   OK : BOOL ;	//Desired DDS = Active DDS reported by drive
   Parm_valid : BOOL ;	//P0820/P0821 configured properly P820=r2090.13 and P821=r2090.14
   Nr_valid : BOOL ;	//Supplied DDS nbr is in valid range 0..2
  END_STRUCT ;	
END_VAR
VAR_TEMP
  Page_Sel_0 : BOOL ;	//1: Parameter Nr > 1999
  P_Address : WORD ;	//Peripheral address for SFC14/15
  P_Job_bits : DWORD ;	//JOb processing
  Job_fault_NR : WORD ;	//Request fault number
  Job_bit_field : DWORD ;	//Job processing
  Job_identifier : WORD ;	//Job processing
  PCD_Address : DWORD ;	//Address as pointer
  DDS0_Parm : DINT ;	
  DDS0_Bit : DINT ;	
  DDS1_Parm : DINT ;	
  DDS1_Bit : DINT ;	
  TmpDint : DINT ;	
END_VAR
BEGIN
NETWORK
TITLE =Version history
//v 2.16 24Jan20/STP
//        - For job 23 load parameter depending on drive type:
//          MM4:      r2110, index 3, identifier b#16#11 (multi)
//          Sinamics: r2132, index 0, identified b#16#1  (single)
//v 2.15 22Jan20/STP
//        - Added job 26 r0024 actual motor frequency and send this value to
//          the interface output as opposed to the calculated value. Value in Hz
//          for both MicroMaster and Sinamics.
//        - Added/corrected tag comments.
//        - Corrected MM drive detection (used >= and <= instead of > and <). 
//        - Moved internal error flag to commissioning structure.
//        - Requires regenerating instance data block.
//v 2.14 06May19/STP
//        - Bug fix: job 25 index was incorrectly set to 1.
//        - Modified drive detection.
//v 2.13 25Jan19/STP
//        - Automatically detect MM420/440 or Sinamics G120 for DDS
//          switching. With MM4, read active DDS from r51 (default). With
//          G120, read from r837.
//          Write appropriate parameter number to Job_25.Parameter_Nr
// v 2.12 24Sep18/STP
//        - Convert #Speed to ABS value.
//        - DDS selection using P820=r2090.13; P821=r2090.14
//        - DDS selection now works for Sinamics drives as well.
//        - Send speed setpoint unconditionally.
// v 2.11 01Aug18/STP
//        - DP error code 91001 exceeded INT boundary, changed to 9001.
//          Changed all internal 1,000 codes to 9,000 as this is a range
//          available for both MM4 as well as Sinamics.
//        - Changed diag code output from INT to DINT for Sinamics.
//        - The extended job bits were not cleared. Corrected in NW22 by
//          writing DWord to #Data_fault.
// v 2.10 11Jun18/STP
//        - Version 2.9 introduced the problem that when switching 
//          the custom RW job from a parameter nbr to 0 it triggered 
//          an internal error on job 3. Worked around this by stop
//          writing the parameter nbr to job 3 (remains at last value).
//        - Rated motor RPM is DWORD, needs conversion to float for 
//          #Frequency calculation.
// v 2.9  24May18/STP
//        - Added capability to select Drive Data Set by sending
//          STW.12 and .15 to P0280/P0281.
//          (Added jobs 23..25 used for this, leaving 7 jobs available.)
//        - Properly named the jobs.
// v 2.8  25Aug17/STP
//        - Simplified interface.
//        - Added 16 additional custom parameter jobs.
//        - Removed parameter cycle timing.
//        - Removed fault delay (will be fixed later).
//        - Moved custom R/W job 3 interface to Config strusture.
//        - Moved commissioning variables to separate structure.
//        - Added optional Coast input to control OFF2.
// v2.6.3 25Apr15/STP
//        Moved custom parameter to STAT area.
//        Moved Parm R/W bools to STAT area.
// v2.6.2 28Oct14/STP
//        Moved the fault delay to the STAT area and fixed its value to 30.
// v2.6.1 28Oct14/STP
//        Filter small values for torque/current.
// v2.6   18Apr13/STP
//        Return absolute values for current/torque.
// v2.5   15Jan13/STP
//        Fixed jobs 1/2 to read current/torque.
//        Transformed job 10 to custom READ job A.
//        Left job 3 for custom read/write as job B.
// v2.4   10Jan13/STP
//        Moved several parms to STAT area.
//        Added OFF2 input (coast to stop).
// -----------------------------------------------------------------
// Fault:
//      1 ..  999: Fault messages from MM 440
//           9001: DP Fault
// -----------------------------------------------------------------
// Fault automatic commissioning 
//           9002: Data fault in case of automatical commissioning
//           9006: Not Siemens-inverter
//           9007: Wrong Micromaster type 
//           9008: Old firmware version
//           9009: Quick commissioning blocked
      NOP   0; 

NETWORK
TITLE =Regular job requests
//19Sep17: (STP) Indicate which jobs are needed.
      L     #Job_1.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.RW_Request_1; // Initiate job 1 actual motor current

      L     #Job_2.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.RW_Request_2; // Initiate job 2 actual motor torque

      L     #Job_17.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_17; // Initiate job

      L     #Job_18.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_18; // Initiate job

      L     #Job_19.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_19; // Initiate job

      L     #Job_20.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_20; // Initiate job

      L     #Job_21.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_21; // Initiate job

      L     #Job_22.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_22; // Initiate job

      L     #Job_23.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_23; // Initiate job

      L     #Job_24.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_24; // Initiate job

      L     #Job_25.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_25; // Initiate job

      L     #Job_26.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_26; // Initiate job

      L     #Job_27.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_27; // Initiate job

      L     #Job_28.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_28; // Initiate job

      L     #Job_29.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_29; // Initiate job

      L     #Job_30.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_30; // Initiate job

      L     #Job_31.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_31; // Initiate job

      L     #Job_32.Parameter_Nr; 
      L     0; 
      >I    ; 
      =     #Job.R_Request_32; // Initiate job

NETWORK
TITLE =Job 3 custom R/W: Prepare
//The custom R/W was modified. After having extended the jobs from 16 to 32, the 
//custom R/W job triggered an internal error when the requested parameter became 
//0. IN order to work around this, we simply stop returning the parameter value, 
//without actually changing job 3 (so it maintains the parameter number, but 
//stops requesting it).
      A(    ; 
      A(    ; 
      L     L#0; 
      T     #Config.Value; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      A     BR; 
      )     ; 
      A(    ; 
      L     #Config.Parameter_nr; 
      L     0; 
      >I    ; 
      )     ; 
      JNB   _001; 
      L     #Config.Parameter_nr; 
      T     #Job_3.Parameter_Nr; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: A     BR; 
      )     ; 
      JNB   _002; 
      L     #Config.Parameter_index; 
      T     #Job_3.Index; 
_002: NOP   0; 
NETWORK
TITLE =Job 3 custom R/W: Request current value

      AN    #Job.RW_Request_3; 
      AN    #Config.Write_new; 
      A(    ; 
      L     #Config.Parameter_nr; 
      L     0; 
      >I    ; 
      )     ; 
      JNB   _003; 
      L     W#16#1; 
      T     #Job_3.Identifier; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_003: A     BR; 
      S     #Job.RW_Request_3; 
NETWORK
TITLE =Job 3 custom R/W: Write new value

      A(    ; 
      AN    #Job.RW_Request_3; 
      A     #Config.Write_new; 
      A(    ; 
      L     #Config.Parameter_nr; 
      L     0; 
      >I    ; 
      )     ; 
      JNB   _004; 
      L     W#16#2; 
      T     #Job_3.Identifier; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_004: A     BR; 
      )     ; 
      JNB   _005; 
      L     #Config.Value_new; 
      T     #Job_3.Value; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_005: A     BR; 
      S     #Job.RW_Request_3; 
      R     #Config.Write_new; 
NETWORK
TITLE =Job 3 custom R/W: Copy returned value

      AN    #Data_fault.JOB.RW_Request_3; 
      A(    ; 
      L     #Config.Parameter_nr; 
      L     0; 
      >I    ; 
      )     ; 
      JNB   _006; 
      L     #Job_3.Value; 
      T     #Config.Value; 
_006: NOP   0; 
NETWORK
TITLE =Call SFC14 for read

      L     #ADDRESS; 
      T     #P_Address; 
      SLD   3; 
      T     #PCD_Address; 
      LAR1  ; 
      L     PID [AR1,P#8.0]; 
      LAR1  P##PCD_receive; 
      T     DID [AR1,P#0.0]; 
      L     0; 
      ==D   ; 
      JC    Ne0a; 

      L     #Intern.Fault_DP_SFC14_15; 
      ==I   ; 
      AN    #Intern.Job_an; 
      JC    FE0; 

Ne0a: CALL SFC   14 (
           LADDR                    := #P_Address,
           RET_VAL                  := #Intern.Fault_DP_SFC14_15,
           RECORD                   := #PKW.RECEIVE);

NETWORK
TITLE =Fault

FE0:  L     #Job_13.Last_warning_1; 
      L     0; 
      <>D   ; 
      O     #PCD_receive.Warning; 
      =     #Warning; 
      =     #Job.R_Last_warnings; 

      L     #Intern.Fault_DP_SFC14_15; 
      L     0; 
      <>I   ; 
      =     #Intern.Fault_DP_PCD_access; 

      A     #Intern.Fault_DP_PCD_access; 
      AN    #Intern.Trans_Para.Stop_fault_estimation; 
      S     #Intern.DP_fault; 

      A     #Intern.Fault_DP_PCD_access; 
      A     #Intern.Trans_Para.Stop_fault_estimation; 
      JC    AN0; 

      A     #Intern.DP_fault; 
      S     #Intern.err; 
      JCN   Fe0b; 

      L     L#9001; // #Intern.Fehler_DP_SFC14_15 was:1001
      T     #Job_14.Last_fault_1; 
      L     0; 
      T     #Job_14.Last_fault_2; 

      L     0; 
      L     #Intern.Fault_DP_SFC14_15; 
      ==I   ; 
      JC    Fe0d; 

      L     #Intern.Fault_DP_SFC14_15; 
      T     #Data_fault.DP_Add_info; 

      JU    Fe0d; 

Fe0b: L     #Job_14.Last_fault_1; 
      L     0; 
      <>I   ; 
      O(    ; 
      L     #Job_15.Last_fault_values_1; 
      <>I   ; 
      )     ; 
      O     #PCD_receive.Fault; 
      S     #Job.R_Last_faults; 
      S     #Job.R_Last_fault_values; 

      A     #PCD_receive.Fault; 
      S     #Intern.err; 

Fe0d: O     #RESET; 
      O     #Intern.F_Reset_Internal; 
      =     #PCD_send.Fault_acknowledge; 
      JCN   AN0; 

      R     #Intern.F_Reset_Internal; 
      S     #Job.R_Last_faults; 
      S     #Job.R_Last_fault_values; 
      S     #Job.R_Firmware_version; 
      R     #Intern.DP_fault; 
      R     #Intern.err; 
      R     #Commission.Data_transfer_running; 
      R     #Intern.Trans_Para.Stop_fault_estimation; 
      R     #Intern.Motor_data_identificat; 
      R     #Commission.IO_W_Parameters; 

      L     0; 
      T     #Intern.Trans_Para.Status; 

AN0:  NOP   0; 

// ----------------------------------------------------------------------------
// Fault status to interface
// ----------------------------------------------------------------------------

      A     #Intern.err; 
      =     #Fault; 

NETWORK
TITLE =SET UP DRIVE FOR START
//*** ADDED BY STP ***
//
//Set up the enable signal internal to the FB. We need an external run permissive 
//and a valid speed setpoint.
//
//The documentation states that with 0% setpoint with the enable signal ON the 
//drive is stationary and could cause the motor temp to rise.
//
//Starting drive:
//   * Set OFF3 = 1 (if not required, assign '1' permanently)
//   * #Drive_ready must be 1 after:
//        # Drive is stationary
//        # #PCD_send.OFF2=1 (no active OFF2 stop)
//        # #PCD_send.OFF3=1 (no active OFF3 stop)
//        # No fault/no error
//        # #Enable=0
//        # Not switching Drive Data Sets
//        # No QC running
//   * Enter a valid speed setpoint.
//   * Set #Enable=1
//
//10Jan13: (STP) Added OFF2 since it is now also used as input.
//24May18: (STP) Interrupt enable signal while switching data sets.
      A(    ; 
      L     #Setpoint; 
      L     0; 
      <>I   ; 
      )     ; 
      A     #Run; 
      A     #PCD_send.OFF2; 
      A     #PCD_send.OFF3; 
      AN    #Fault; 
      A(    ; 
      AN    #Running; 
      AN    #Enable; 
      O     #Enable; 
      )     ; 
      AN    #Commission.Enable_QC; 
      A     #DDS.OK; 
      =     #Enable; 
NETWORK
TITLE =Control - OFF1
//Control Word = Steuerwort
//Priority sequence: OFF2, OFF3, OFF1.
//
//OFF1:
// - Valid start conditions (ENABLE).
// - Drive reported OFF2 on.
// or
// - Motor ident is running
//
//STW bits:
// 0 : 1 = Sets inverter to 'ready to run' state.
//     0 = ramp down along RFG, pulses disabled once f < f_min
// 1 : 0 = instanteneous pulse removal, drive coasts to stop
// 2 : 0 = rapid stop along RFG (P1135)
// 3 : 1 = closed-loop control + pulses enabled
// 4 : 0 = disable RFG, inverter remains in on state
// 5 : 1 = enable RFG
//     0 = currently setpoint by RFG is frozen
// 6 : 0 = disable setpoint, value selected at RFG input is set to 0
//     1 = enable setpoint, value selected at RFG input is activated
// 7 : 1 = fault acknowledge
// 8 : 1 = CW inching
// 9 : 1 = CCW inching
//10 : 1 = setpoints valid, master transfers valid setpoints
//     0 = setpoints invalid
//11 : 1 = setpoint is inverted, motor rotates CCW with positive setpoint
//     0 = setpoint not inverted, motor rotates CW with positive setpoint
//12 : not used
//13 : 1 = motorized potentiometer up
//14 : 1 = motorized potentiometer down
//15 : 0 = remote control
//     1 = local control active (BOP/AOP)
// ----------------------------------------------------------------------------
// OFF1
// ----------------------------------------------------------------------------
//
// OFF1 must transition from 0 to 1 to start
// OFF2 must be enabled prior, so wait until drive confirmed OFF2
      A     #Enable; // Valid start conditions
      A     #PCD_receive.OFF2_active; // Drive reported OFF2 on
      O     #Intern.Motor_data_identificat; // Motor ident is running
      =     #PCD_send.OFF1; 

NETWORK
TITLE =Control - OFF2
//10Jan13: (STP) Added OFF2 option. This signal is active low. When coasting is 
//required it can be made the same as the OFF1 input since it has priority.
//
//Priority sequence: OFF2, OFF3, OFF1.
//
//Set OFF2:
// - Coast option is not needed (if not needed always send '1').
// or 
// - Coast option is needed:
// - Valid start conditions (ENABLE).
// or
// - Motor ident is running
// or
// - Keep on when stopped or we could never start.
//
// ----------------------------------------------------------------------------
// OFF2 - Coast stop
// ----------------------------------------------------------------------------
//
// This signal must be '1' before OFF1 is enabled.
      ON    #Coast; // Coast option off
      O     ; 
      A     #Coast; // Coast option on:
      A     #Enable; // ..valid start conditions
      O     #Intern.Motor_data_identificat; // Motor ident is running
      ON    #Running; // Keep on when stopped
      =     #PCD_send.OFF2; 


NETWORK
TITLE =Control - OFF3
//Priority sequence: OFF2, OFF3, OFF1.
//
//OFF3:
// - Keep always on for now.
// - If needed, could slave to E-Stop (then also enable during drive ident).
      SET   ; 
      =     #PCD_send.OFF3; // Quick STOP

NETWORK
TITLE =Send speed setpoint %
//Speed setpoint = Hauptsollwert HSW
//
//*** MODIFIED BY STP ***
//
//01Oct18: (STP) v2.12 - Send speed setpoint unconditioally. It is a nice 
//troubleshooting tool, the drive no longer reads INHIBIT in standstill.
// ----------------------------------------------------------------------------
// Scale the setpoint for the inverter
// ----------------------------------------------------------------------------
//
// 0x4000 = 16384 = 100% = P2000 value
// Regardless of the entered rated motor data, P2000 determines the scaling
// THe Micromaster uses frequency (Hz), the Sinamics uses speed (1/min).
      L     #Setpoint; // Limit the upper limit to 0x7FFF (32767)
      L     199; 
      <=I   ; 
      JC    _07a; 
      L     32767; // ..load max, write value
      JU    _07w; 

_07a: L     #Setpoint; // Limit the lower limit to 0x8001 (-32767)
      L     -199; 
      >=I   ; 
      JC    _07b; 
      L     -32767; // ..load min, write value
      JU    _07w; 

_07b: L     #Setpoint; // Scale desired setpoint
      ITD   ; 
      DTR   ; 
      L     1.638400e+002; // Scale to 0x4000=16384=100%=P2000
      *R    ; 
      RND   ; 
_07w: T     #PCD_send.Main_setpoint; // Setpoint sent to drive

NETWORK
TITLE =Receive actual speed %
//Actual speed = Hauptistwert HIW
//
//24Sep18: (STP) v2.12: Convert speed received to absolute value.
      L     #PCD_receive.Speed; 
      ITD   ; 
      DTR   ; 
      L     1.638400e+002; // 100% corresponds HEX 4000 or INT 16384
      /R    ; 
      ABS   ; // Take absolute value
      RND   ; 
      T     #Speed; 
NETWORK
TITLE =Status - Drive stopped
//ZSW (status word = Zustandwort) bits:
//
// 0: 1=Ready for ON: power supply on, electronics initialized, pulses disabled.
// 1: 1=Ready to run: OFF1 on, no fault, inverter can start when 'enable 
//      operation' is active.
// 2: 1=Operation enabled
// 3: 1=Fault active
// 4: 1=OFF2 is active
// 5: 1=OFF3 is active
// 6: 1=Starting lockout (eg due to fault)
// 7: 1=Alarm is active
// 8: 1=No setpoint/actual value deviation (within tolerance range)
// 9: 1=Master control requested; 0=Local operation
//10: 1=f reached (output frequency/speed >= max frequency/speed
//11: 1=Alarm: motor at current limit
//12: 0=Motor holding brake (can be used to control brake)
//13: 0=Motor overload
//14: 1=CW rotation; 0=CCW rotation
//15: 0=Inverter overload (current, temperature)
// Indicate motor at standstill if not recieving speed from drive
      L     0; 
      L     #PCD_receive.Speed; 
      ==I   ; 
      =     #Drive_STOP; 

// Indicate running







// Indicate drive ready


NETWORK
TITLE =Status - Motor running CW

      AN    #Drive_STOP; 
      A     #PCD_receive.Motor_runs_right; 
      =     #Motor_Right; 


NETWORK
TITLE =Status - Motor running CCW

      AN    #Drive_STOP; 
      AN    #PCD_receive.Motor_runs_right; 
      =     #Motor_Left; 


NETWORK
TITLE =Status - Drive running

      O     #Motor_Left; 
      O     #Motor_Right; 
      =     #Running; 


NETWORK
TITLE =Status - Ready

      A     #PCD_receive.Drive_ready; 
      AN    #Commission.IO_W_Parameters; 
      AN    #Commission.Sat_curve; 
      AN    #Commission.Motor_ID; 
      AN    #Fault; 
      AN    #PCD_receive.ON_inhibit_active; 
      =     #Drive_ready; 

NETWORK
TITLE =Alarm status
//We need to delay the fault status for the operator to filter out momentary 
//faults.
//
//*** NOTE ***
//
//We used to delay the fault status. However, I am unable to add a multi-instance 
//SFB4 call here, won't alow me to save it. Will be dealt with later.


NETWORK
TITLE =Write parameters / Drive commissioning
//Read or write motor data
//
      L     #Intern.Trans_Para.Status; 
      JL    ps; 
      JU    ps0; //  0: Main position; prepare and start action
      JU    ps1; //  1: Start RESET to factory setting
      JU    ps2; //  2: Control the end of RESET to factory setting and set quick commissioning
      JU    ps3; //  3: Write parameters step 1  
      JU    ps4; //  3: Write parameters step 2
      JU    ps5; //  5: Control the end of quick commissioning
      JU    ps6; //  6: End of quick commissioning; prepare the transfer of the technological data 
      JU    ps7; //  7: Technological data write step 1
      JU    ps8; //  7: Technological data write step 2
      JU    ps9; //  9: Transfer RAM to EEPROM
      JU    ps10; // 10: Motor identification
      JU    ps11; // 11: Quick commissioning parameters read step 1 
      JU    ps12; // 11: Quick commissioning parameters read step 2 
ps:   L     0; 
      T     #Intern.Trans_Para.Status; 
      JU    psEE; 

// ----------------------------------------------------------------------------
// 0: Main position; prepare and start action
//    Quick commissioning can be processed if the motor is in standstill.
// Prepare to start RESET to factory setting
// Start parameters transfer 
//  P 014: Store mode (RAM/EEPROM)                  Job_5
//  P  10: Commissioning  30: Factory setting       Job_6
//  P 852: BI: Pulse enable       0: Set to 0       Job_4
//         
//  P 964: Read firmware version                    read job
// ----------------------------------------------------------------------------

ps0:  AN    #Commission.IO_W_Parameters; 
      JC    ps0a; 
      O     #Enable; 
      ON    #Commission.Enable_QC; 
      O     #Commission.Internal_error; 
      L     9009; // Fault: quick commissioning function is blocked up   was:1009
      JC    psE5; 
      S     #Commission.Data_transfer_running; 
      S     #Job.W_Store_mode; // Job_5
      S     #Job.W_Pulses_enable; // Job_4
      S     #Job.RW_Commissioning; // Job_6  
      S     #Job.R_Firmware_version; // Job_16 
      L     2; // Identifier: write to RAM
      T     #Job_6.Identifier; 
      L     0; // Identifier: RUN
      T     #Job_6.Value; 
      JU    psE1; 

// ----------------------------------------------------------------------------
// Read parameters
// ----------------------------------------------------------------------------

ps0a: AN    #Commission.IO_R_Parameters; 
      JC    ps0b; 
      O     #Enable; 
      ON    #Commission.Enable_QC; 
      O     #Commission.Internal_error; 
      L     9009; // Fault: quick commissioning function is blocked up was:1009
      JC    psE5; 
      S     #Commission.Data_transfer_running; 
      R     #Intern.Trans_Para.Motor_data_read_end; 
      L     P#2.0; // Beginning of the motor data
      T     #Intern.Trans_Para.P_Parameter_list; 
      L     #Commission.Motor_data_DB; 
      T     #Intern.Trans_Para.DB_NR; 
      OPN   DB [#Intern.Trans_Para.DB_NR]; 
      L     DBW    0; 
      T     #Job_12.Index; 
      L     1; // 1: Read identifier
      T     #Job_12.Identifier; 
      L     11; // Quick commissioning parameters read step 1  
      JU    psE2; 

// ----------------------------------------------------------------------------
//  Motor identification or
// ----------------------------------------------------------------------------

//  Identificate saturation characteristic, only for MM 440


ps0b: AN    #Commission.Sat_curve; 
      AN    #Commission.Motor_ID; 
      JC    psEE; 
      ON    #Commission.Enable_QC; 
      O     #Commission.Internal_error; 
      O     #Fault; 
      L     9009; // Fault: quick commissioning function is blocked up  was:1009
      JC    psE5; 
      S     #Commission.Data_transfer_running; 
      A     #Commission.Motor_ID; 
      L     1; // Identifier: Identification of the all parameters with changes
      JC    ps0c; 
      L     1002; // 1001: MM420   1002: MM440   1003: MM411    1007: MM430
      L     #Job_16.Type_1; // Micromaster type
      L     1007; // Fault: Wrong MICROMASTER type   
      <>I   ; 
      JC    psE5; 
      L     3; // Identifier: Saturation characteristic identification with changes
ps0c: T     #Job_8.Value; // Choose motor data identification
      L     2; // Identifier: write to RAM
      T     #Job_8.Identifier; 
      S     #Job.RW_Motor_identification; 
      L     10; // Motor identification
      JU    psE2; 

// ----------------------------------------------------------------------------
// 1: Start factory setting
// ----------------------------------------------------------------------------

// The version of the drive will be checked up; a fault message will be generate in case of dismatch
// Start parameter transfer                                       
//  P 970: RESET to factory setting   1: start  

ps1:  O     #Job.W_Store_mode; // Job_5
      O     #Job.W_Pulses_enable; // Job_4
      O     #Job.RW_Commissioning; // Job_6
      O     #Job.R_Firmware_version; // Job_16 
      JC    psEE; 
      O     #Data_fault.JOB.R_Firmware_version; // Job_16 
      JC    ps1a; // in case of fault
      L     #Job_16.Firm; 
      L     42; // Identifier Siemens
      <>D   ; 
      L     9006; // Fault: Not Siemens-inverter was:1006
      JC    psE5; 
      L     1001; // 1001: MM420   1002: MM440   1003: MM411    1007: MM430
      L     #Job_16.Type_1; // Micromaster type
      ==I   ; 
      L     117; // min. Firmware version
      JC    ps1c; 
      L     1002; // 1001: MM420   1002: MM440   1003: MM411    1007: MM430
      L     #Job_16.Type_1; // Micromaster type
      ==I   ; 
      L     205; // 206                         // min. Firmware version
      JC    ps1c; 
      L     1003; // 1001: MM420   1002: MM440   1003: MM411    1007: MM430
      L     #Job_16.Type_1; // Micromaster type
      ==I   ; 
      L     110; // min. Firmware version
      JC    ps1c; 
      L     1007; // 1001: MM420   1002: MM440   1003: MM411    1007: MM430
      L     #Job_16.Type_1; // Micromaster type
      ==I   ; 
      L     200; // min. Firmwareversion
      JC    ps1c; 
      L     9007; // Fault: Wrong Micromaster type  was:1007
      JU    psE5; 
ps1c: L     #Job_16.Firmware_version; // Firmware version
      >D    ; 
      L     9008; // Fault: too old Firmware version  was:1008
      JC    psE5; 
      O     #Data_fault.JOB.W_Pulses_enable; // Job_4
      O     #Data_fault.JOB.RW_Commissioning; // Job_6
ps1a: S     #Commission.Internal_error; 
      JC    psE3; 
      S     #Intern.Trans_Para.Reset_data_fault_intern; // the fault has to be acknowledged if the parameter is absent
      S     #Job.RW_Commissioning; // Job_6  
      S     #Job.RW_Factory_setting; // JOb_7
      L     30; // Identifier: Factory setting
      T     #Job_6.Value; 
      L     2; // Identifier: write to RAM
      T     #Job_7.Identifier; 
      L     1; 
      T     #Job_7.Value; // Identifier: Factory setting
      JU    psE1; 

// ----------------------------------------------------------------------------
//  2: Control the end of RESET to factory setting, set quick commissioning
// ----------------------------------------------------------------------------

ps2:  O     #Job.RW_Commissioning; // Job_6
      O     #Job.RW_Factory_setting; // Job_7
      JC    psEE; 
      O     #Data_fault.JOB.RW_Commissioning; // Job_6
      O     #Data_fault.JOB.RW_Factory_setting; // Job_7
      JC    psE3; 
      L     1; // Identifier: read
      T     #Job_6.Identifier; 
      T     #Job_7.Identifier; 
      L     #Job_6.Value; // P 10 
      L     0; 
      <>I   ; 
      JC    ps2a; 
      L     #Job_7.Value; // P 970
      <>I   ; 
ps2a: S     #Job.RW_Commissioning; // Job_6
      S     #Job.RW_Factory_setting; // Job_7
      JC    psEE; 

// ----------------------------------------------------------------------------
// Set quick commissioning
// ----------------------------------------------------------------------------

// Some parameters will be transfered again, because they were reseted during the "RESET to factory setting"
// Job 12 will be prepared for the drive data sets transfer
// Job 6 will be prepared for the end of quick commissioning
// Start parameters transfer 
//  P  10: Commissioning parameters   1: Quick commissioning

      S     #Job.W_Pulses_enable; // Job_4
      S     #Job.RW_Commissioning; // Job_6
      OPN   DB [#Commission.Motor_data_DB]; 
      L     2; // Identifier: write to RAM
      T     #Job_6.Identifier; 
      L     1; // Identifier: Quick commissioning
      T     #Job_6.Value; 
      L     P#2.0; // Beginning of the motor data
      T     #Intern.Trans_Para.P_Parameter_list; 
      L     DBW    0; 
      T     #Job_12.Index; 
      L     2; // Identifier: write to RAM
      T     #Job_12.Identifier; 
      JU    psE1; 

// ----------------------------------------------------------------------------
// 3: Write parameters step 1
// ----------------------------------------------------------------------------

ps3:  O     #Job.RW_Commissioning; // Job_6
      O     #Job.W_Pulses_enable; // Job_4
      JC    psEE; 
      O     #Data_fault.JOB.RW_Commissioning; // Job_6
      O     #Data_fault.JOB.W_Pulses_enable; // Job_4
      JC    psE3; 
      OPN   DB [#Commission.Motor_data_DB]; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      T     #Job_12.Parameter_Nr; // Write parameter-Nr
      L     DBD [AR1,P#2.0]; // Drive_data.Value_n
      T     #Job_12.Value; 
      S     #Job.RW_Drive_data; // Job_12
      JU    psE1; 

// ----------------------------------------------------------------------------
// 4: Write parameters step 2
// ----------------------------------------------------------------------------

//  P 3900: end of quick commissioning   3: Quick commissioning

ps4:  A     #Job.RW_Drive_data; // Job_12
      JC    psEE; 
      A     #Data_fault.JOB.RW_Drive_data; // Job_12
      JC    ps4b; 
      L     1; // 1: Read identifier
      T     #Job_6.Identifier; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      OPN   DB [#Commission.Motor_data_DB]; 
ps4a: +AR1  P#6.0; 
      TAR1  #Intern.Trans_Para.P_Parameter_list; 
      L     W#16#FFFF; // End identifier
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      ==I   ; 
ps4b: S     #Job.W_End_Quick_comm; // Job_9
      JC    psE1; 
      L     0; 
      ==I   ; 
      JC    ps4a; 
      L     #Intern.Trans_Para.Status; 
      +     -1; 
      JU    psE2; 

// ----------------------------------------------------------------------------
// 5: Control the end of quick commissioning
// ----------------------------------------------------------------------------

ps5:  A     #Job.W_End_Quick_comm; // Job_9
      JC    psEE; 
      O     #Data_fault.JOB.W_End_quick_comm; // Job_9
      JC    psE3; 
      S     #Job.RW_Commissioning; // Job_6
      S     #Job.R_End_QC; // Job_11
      L     1; 
      T     #Job_6.Identifier; 
      JU    psE1; 

// ----------------------------------------------------------------------------
// 6: End quick commissioning; prepare transfer technological parameters
// ----------------------------------------------------------------------------

ps6:  O     #Job.RW_Commissioning; // Job_6
      O     #Job.R_End_QC; // Job_11
      JC    psEE; 
      O     #Data_fault.JOB.RW_Commissioning; // Job_6
      O     #Data_fault.JOB.R_End_QC; // Job_11
      JC    psE3; 
      L     #Job_6.Value; // P 10 
      L     0; 
      <>I   ; 
      JC    ps6a; 
      L     #Job_11.Value; // P 3900
      <>I   ; 
ps6a: S     #Job.R_End_QC; // Job_11
      S     #Job.RW_Commissioning; // Job_6
      JC    psEE; 
      A     #Data_fault.JOB.RW_Drive_data; // Job_12
      JN    psE3; 
      L     0; 
      L     #Commission.Tech_data_DB; 
      <>I   ; 
      JC    ps6b; 
      L     #Commission.Motor_data_DB; 
      T     #Intern.Trans_Para.DB_NR; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      +AR1  P#2.0; 
      TAR1  #Intern.Trans_Para.P_Parameter_list; 
      JU    psE1; 
ps6b: T     #Intern.Trans_Para.DB_NR; 
      L     P#0.0; 
      T     #Intern.Trans_Para.P_Parameter_list; 
      JU    psE1; 

// ----------------------------------------------------------------------------
// 7: Write technological data step 1
// ----------------------------------------------------------------------------

ps7:  OPN   DB [#Intern.Trans_Para.DB_NR]; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
ps7b: L     W#16#EEEE; 
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      ==I   ; 
      JC    ps7c; 
      L     0; 
      <>I   ; 
      JC    ps7a; 
      +AR1  P#8.0; 
      TAR1  #Intern.Trans_Para.P_Parameter_list; 
      JU    ps7b; 
ps7a: L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      T     #Job_12.Parameter_Nr; // Write Parameter-Nr
      L     DBW [AR1,P#2.0]; 
      T     #Job_12.Index; 
      L     DBD [AR1,P#4.0]; // Drive_data.Value_n
      T     #Job_12.Value; 
      SET   ; 
      S     #Job.RW_Drive_data; // Job_12
      JU    psE1; 
ps7c: L     2; // Identifier: write to RAM
      T     #Job_10.Identifier; 
      L     1; // Start RAM -> EEPROM
      T     #Job_10.Value; 
      S     #Job.RW_RAM_to_EEPROM; // Job_10
      S     #Intern.Trans_Para.Stop_fault_estimation; 
      L     9; // 9: Copy RAM to EEPRO
      JU    psE2; 

// ----------------------------------------------------------------------------
// 8: Write technological data step 2
// ----------------------------------------------------------------------------

ps8:  A     #Job.RW_Drive_data; // Job_12
      JC    psEE; 
      A     #Data_fault.JOB.RW_Drive_data; // Job_12
      JC    psE3; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      +AR1  P#8.0; 
      TAR1  #Intern.Trans_Para.P_Parameter_list; 
      L     #Intern.Trans_Para.Status; 
      +     -1; 
      JU    psE2; 

// ----------------------------------------------------------------------------
// 9: Copy RAM to EEPROM
// ----------------------------------------------------------------------------

ps9:  A     #Job.RW_RAM_to_EEPROM; // Job_10
      JC    psEE; 
      L     1; // Identifier: read
      T     #Job_10.Identifier; 
      L     #Job_10.Value; 
      L     0; // Function RAM -> EEPROM ends
      <>I   ; 
      S     #Job.RW_RAM_to_EEPROM; // Job_10
      JC    psEE; 
      R     #Intern.Trans_Para.Stop_fault_estimation; 
      S     #Intern.Trans_Para.Reset_data_fault_intern; 
      S     #Intern.F_Reset_Internal; 
      JU    psE4; 

// ----------------------------------------------------------------------------
// 10: Motor identification
// ----------------------------------------------------------------------------

ps10: A     #Job.RW_Motor_identification; 
      JC    psEE; 
      A     #Data_fault.JOB.RW_Motor_identification; 
      JC    psE3; 
      L     1; // Identifier: read
      T     #Job_8.Identifier; // Motor data identification
      L     #Job_8.Value; // Motor data identification
      L     0; // Function RAM -> EEPROM ends
      <>I   ; 
      AN    #Fault; 
      S     #Job.RW_Motor_identification; // Job_8
      =     #Intern.Motor_data_identificat; 
      JC    psEE; 
      A     #Fault; 
      JC    psE4; 
      JU    ps7c; 

// ----------------------------------------------------------------------------
// 11: Read parameters step 1  
// ----------------------------------------------------------------------------

ps11: LAR1  #Intern.Trans_Para.P_Parameter_list; 
      OPN   DB [#Intern.Trans_Para.DB_NR]; 
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      T     #Job_12.Parameter_Nr; // Write Parameter-Nr
      AN    #Intern.Trans_Para.Motor_data_read_end; 
      JC    p11a; 
      L     DBW [AR1,P#2.0]; // Drive_data.Index_n
      T     #Job_12.Index; // Write Index
p11a: SET   ; 
      S     #Job.RW_Drive_data; // Job_12
      JU    psE1; 

// ----------------------------------------------------------------------------
// 12: Read parameters step 2  
// ----------------------------------------------------------------------------

ps12: A     #Job.RW_Drive_data; // Job_12
      JC    psEE; 
      A     #Data_fault.JOB.RW_Drive_data; // Job_12
      JC    psE3; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      OPN   DB [#Intern.Trans_Para.DB_NR]; 
      L     #Job_12.Value; 
      A     #Intern.Trans_Para.Motor_data_read_end; 
      JC    p12f; 
      T     DBD [AR1,P#2.0]; // Drive_data.Value_n   Motor data
      JU    p12a; 
p12f: T     DBD [AR1,P#4.0]; // Drive_data.Value_n   Technological data
p12a: +AR1  P#6.0; 
      AN    #Intern.Trans_Para.Motor_data_read_end; 
      JC    p12e; 
      +AR1  P#2.0; 
p12e: TAR1  #Intern.Trans_Para.P_Parameter_list; 
      L     W#16#FFFF; // Motor data end identifier
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      ==I   ; 
      S     #Intern.Trans_Para.Motor_data_read_end; 
      JC    p12b; // wenn Parameterliste vollständig übertragen 
      L     0; 
      ==I   ; 
      JC    p12a; 
      L     W#16#EEEE; // Technological data end identifier
      L     DBW [AR1,P#0.0]; // Drive_data.Parameter_n
      ==I   ; 
      JC    psE4; 
      JU    p12d; 
p12b: L     0; 
      L     #Commission.Tech_data_DB; 
      <>I   ; 
      JC    p12c; 
      L     #Commission.Motor_data_DB; 
      T     #Intern.Trans_Para.DB_NR; 
      LAR1  #Intern.Trans_Para.P_Parameter_list; 
      +AR1  P#2.0; 
      TAR1  #Intern.Trans_Para.P_Parameter_list; 
      JU    p12d; 
p12c: T     #Intern.Trans_Para.DB_NR; 
      L     P#0.0; 
      T     #Intern.Trans_Para.P_Parameter_list; 
p12d: L     #Intern.Trans_Para.Status; 
      +     -1; 
      JU    psE2; 

psE3: L     9002; // Fault in case of automatical commissioning was:1002
psE5: T     #Data_fault.Fault_Commissioning; 
      SET   ; 
      S     #Commission.Internal_error; 
psE4: R     #Commission.Data_transfer_running; 
      R     #Commission.IO_W_Parameters; 
      R     #Commission.IO_R_Parameters; 
      R     #Commission.Sat_curve; 
      R     #Commission.Motor_ID; 
      L     0; 
      JU    psE2; 
psE1: L     #Intern.Trans_Para.Status; 
      +     1; 
psE2: T     #Intern.Trans_Para.Status; 
psEE: NOP   0; 
NETWORK
TITLE =Fault acknowledge Start process
//Set all fault bits und fault messages to 0
//
//01Aug18: (STP) Include the extended job booleans by writing Dint.
      AN    #RESET; 
      AN    #Intern.Trans_Para.Reset_data_fault_intern; 
      JC    FEE; 
      R     #Intern.Trans_Para.Reset_data_fault_intern; 
      R     #Commission.Internal_error; 
      LAR1  P##Data_fault; 
      L     L#0; 
      T     DID [AR1,P#0.0]; 
      T     #Data_fault.Nr; 
      T     #Data_fault.DP_Add_info; 
      T     #Data_fault.Request_Nr; 
      T     #Data_fault.Index; 
      T     #Data_fault.Parameter_Nr; 
      T     #Data_fault.Fault_Commissioning; 
FEE:  NOP   0; 
NETWORK
TITLE =Process parameter jobs

      L     P##Job; 
      T     #P_Job_bits; 

      A     #Intern.Job_an; 
      JC    pa3; 
pa1:  LAR2  #P_Job_bits; 
      L     0; 
      L     DID [AR2,P#0.0]; 
      ==D   ; 
      JC    pa1f; 
      L     #Intern.Job_counter; 
      TAK   ; 
      CAD   ; 
      RRD   ; 
      CAD   ; 
      T     #Job_bit_field; 
      LAR2  P##Job_bit_field; 
      L     32; // Increased from 16
pa1b: A     L [AR2,P#0.0]; 
      JC    pa1c; 
      +AR2  P#0.1; 
      LOOP  pa1b; 
pa1f: L     0; 
      T     #Intern.Job_counter; 
      SET   ; 
      R     #Intern.Job_an; 
      JU    pae; 
pa1c: L     32; // Increased from 16
      TAK   ; 
      -I    ; 
      L     #Intern.Job_counter; 
      +I    ; 
      L     32; // Increased from 16
      <I    ; 
      JC    pa1d; 
      -I    ; 
      T     #Intern.Job_counter; 
      JU    pa1e; 
pa1d: TAK   ; 
pa1e: T     #Intern.Job_counter; 
      L     #P_Job_bits; 
      +D    ; 
      T     #Intern.Job_P_BITS; 


      L     #Intern.Job_counter; 
      JL    Au1; 
      JU    Au1; 
      JU    Au2; 
      JU    Au3; 
      JU    Au4; 
      JU    Au5; 
      JU    Au6; 
      JU    Au7; 
      JU    Au8; 
      JU    Au9; 
      JU    Au10; 
      JU    Au11; 
      JU    Au12; 
      JU    Au13; 
      JU    Au14; 
      JU    Au15; 
      JU    Au16; 
      JU    Au17; // Increased from 16
      JU    Au18; 
      JU    Au19; 
      JU    Au20; 
      JU    Au21; 
      JU    Au22; 
      JU    Au23; 
      JU    Au24; 
      JU    Au25; 
      JU    Au26; 
      JU    Au27; 
      JU    Au28; 
      JU    Au29; 
      JU    Au30; 
      JU    Au31; 
      JU    Au32; 
Au1:  LAR1  P##Job_1; 
      JU    pa2a; 
Au2:  LAR1  P##Job_2; 
      JU    pa2a; 
Au3:  LAR1  P##Job_3; 
      JU    pa2a; 
Au4:  LAR1  P##Job_4; 
      JU    pa2a; 
Au5:  LAR1  P##Job_5; 
      JU    pa2a; 
Au6:  LAR1  P##Job_6; 
      JU    pa2a; 
Au7:  LAR1  P##Job_7; 
      JU    pa2a; 
Au8:  LAR1  P##Job_8; 
      JU    pa2a; 
Au9:  LAR1  P##Job_9; 
      JU    pa2a; 
Au10: LAR1  P##Job_10; 
      JU    pa2a; 
Au11: LAR1  P##Job_11; 
      JU    pa2a; 
Au12: LAR1  P##Job_12; 
      JU    pa2a; 
Au13: LAR1  P##Job_13; 
      JU    pa2a; 
Au14: LAR1  P##Job_14; 
      JU    pa2a; 
Au15: LAR1  P##Job_15; 
      JU    pa2a; 
Au16: LAR1  P##Job_16; 
      JU    pa2a; 
Au17: LAR1  P##Job_17; // Increased from 16
      JU    pa2a; 
Au18: LAR1  P##Job_18; 
      JU    pa2a; 
Au19: LAR1  P##Job_19; 
      JU    pa2a; 
Au20: LAR1  P##Job_20; 
      JU    pa2a; 
Au21: LAR1  P##Job_21; 
      JU    pa2a; 
Au22: LAR1  P##Job_22; 
      JU    pa2a; 
Au23: LAR1  P##Job_23; 
      JU    pa2a; 
Au24: LAR1  P##Job_24; 
      JU    pa2a; 
Au25: LAR1  P##Job_25; 
      JU    pa2a; 
Au26: LAR1  P##Job_26; 
      JU    pa2a; 
Au27: LAR1  P##Job_27; 
      JU    pa2a; 
Au28: LAR1  P##Job_28; 
      JU    pa2a; 
Au29: LAR1  P##Job_29; 
      JU    pa2a; 
Au30: LAR1  P##Job_30; 
      JU    pa2a; 
Au31: LAR1  P##Job_31; 
      JU    pa2a; 
Au32: LAR1  P##Job_32; 
pa2a: TAR1  #Intern.P_Job; 
      A     #Intern.Fault_DP_PCD_access; 
      JC    pa7c; 
      L     0; 
      T     #Intern.Index_counter; 
      T     #Intern.Parameter_Nr_actual; 
      L     DIB [AR1,P#4.0]; 
      ==I   ; 
      L     22; 
      JC    pa7a; 
      TAK   ; 
      SRW   5; 
      JP    pa2b; 
//0: Einzelparameter übertragen 
      L     DIW [AR1,P#2.0]; // Job_n_Index
pa2b: T     #Intern.Index_counter; 
      L     0; 
pa2c: T     #Intern.Offset_value; 
// 
// Auftrag anstoßen
// hier muß AR1 auf den Auftragsblock zeigen
pa21: SET   ; 
      S     #Intern.Job_an; 
      L     DIB [AR1,P#4.0]; 
      AW    W#16#F; 
      JL    pa4g; 
      JU    pa4g; // Job identifier 0: unknown job identifier
      JU    pa4h; // Job identifier 1: read  
      JU    pa4i; // Job identifier 2: write to RAM
      JU    pa4j; // Job identifier 3: write to EEPROM
pa4g: L     24; // Fault 24: unknown job identifier
      JU    pa7a; 
pa4h: L     6; // 6: read job identifier for parameter
      JU    pa4f; 
pa4i: L     DIB [AR1,P#5.0]; // Job_n_Identifier_internal:   job identifier for MM4xx
      L     8; // Modify parameter value (Array double word)  
      ==I   ; 
      JC    pa4c; 
      L     7; // Modify parameter value (Array)
      JU    pa4f; 
pa4j: L     DIB [AR1,P#5.0]; // Job_n_Identifier_internal:   job identifier for MM4xx
      L     12; // Modify parameter value (Array word) and save in EEPROM 
      ==I   ; 
      JC    pa4c; 
      L     11; // Modify parameter value (Array word) and save in EEPROM
pa4f: T     DIB [AR1,P#5.0]; // Job_n_Identifier_internal:   job identifier for MM4xx
pa4c: L     2000; // Parameter 2000   (Parameter page 1: Parameter 0 to 1999)
      L     DIW [AR1,P#0.0]; // Job_n_Parameter-Nr
      T     #Intern.Parameter_Nr_actual; 
      >I    ; 
      =     #Page_Sel_0; 
      JC    pa4a; // if Parameter Nr < 2000
      TAK   ; 
      -I    ; 
pa4a: L     DIB [AR1,P#5.0]; // Job_n_Identifier_internal:   job identifier for MM4xx
      SLW   12; 
      OW    ; 
      T     #PKW.SEND.Identifier_Nr; 

      L     #Intern.Index_counter; // Job_n_Index (Subparameter Nr)
      SLW   8; 
      A     #Page_Sel_0; 
      JC    pa4b; 
      OW    W#16#80; // Parameter > 1999 choose
pa4b: T     #PKW.SEND.Index; 
      L     0; 
      T     #Intern.Watch_Dog_write; 
      L     DIB [AR1,P#4.0]; 
      AW    W#16#F; 
      L     1; 
      ==I   ; 
      JC    pae; 

      L     #Intern.Offset_value; 
      +AR1  ; 
      L     DID [AR1,P#6.0]; // Job_n_Value
      T     #PKW.SEND.Value; 
      JU    pae; 
// 
// Control request end
pa3:  LAR1  #Intern.P_Job; 
      A     #Intern.Fault_DP_PCD_access; 
      JC    pa7c; 
      L     #PKW.RECEIVE.Identifier_Nr; 
      SLW   4; // Bit 12 to 15
      L     #PKW.SEND.Identifier_Nr; 
      SLW   4; // Bit 12 to 15
      <>I   ; 
      JC    pa3d; // if request running
      L     #PKW.RECEIVE.Index; 
      L     #PKW.SEND.Index; //equal Nr 
      <>I   ; 
      JC    pa3d; // if request running
      L     7; // Response identifier: request is not possible
      L     #PKW.RECEIVE.Identifier_Nr; 
      SRW   12; // Isolate response identifier
      <=I   ; 
      JC    pa7; // if 7: Fault or 8: no priority for PKW interface

      L     DIB [AR1,P#4.0]; 
      AW    W#16#F; 
      L     1; 
      ==I   ; 
      JC    pa3a; 
      L     #PKW.SEND.Value; 
      L     #PKW.RECEIVE.Value; 
      ==I   ; 
      JC    pa3b; 

pa3d: L     5000; // 1000                        
      L     #Intern.Watch_Dog_write; 
      +     1; 
      T     #Intern.Watch_Dog_write; 
      >I    ; 
      JC    pae; 
      L     23; 
      JU    pa7a; 
pa3a: L     #Intern.Offset_value; 
      +AR1  ; 
      L     #PKW.RECEIVE.Value; 
      T     DID [AR1,P#6.0]; 
      LAR1  #Intern.P_Job; 
// Unterparameterliste bearbeiten
pa3b: L     DIW [AR1,P#2.0]; 
      L     #Intern.Index_counter; 
      <=I   ; 
      JC    pa3c; 
      +     1; 
      T     #Intern.Index_counter; 
      L     #Intern.Offset_value; 
      +     32; 
      JU    pa2c; 

pa3c: LAR2  #Intern.Job_P_BITS; 
      R     DIX [AR2,P#0.0]; 
      R     #Intern.Job_an; 
      JU    pa9; 
// Fehler bearbeiten
pa7:  L     8; 
      ==I   ; 
      L     21; 
      JC    pa7a; 
      L     5; 
      L     #PKW.RECEIVE.Value; 
      <>I   ; 
      JC    pa7a; 
      L     DIB [AR1,P#5.0]; 
      SRW   1; 
      L     1; 
      JP    pa7b; 
      L     -1; 
pa7b: L     DIB [AR1,P#5.0]; 
      +I    ; 
      T     DIB [AR1,P#5.0]; 
      JU    pa21; 
pa7c: L     25; 
pa7a: T     #Job_fault_NR; 
      LAR2  #Intern.Job_P_BITS; 
      SET   ; 
      R     DIX [AR2,P#0.0]; 
      R     #Intern.Job_an; 
      AN    #Intern.Trans_Para.Stop_fault_estimation; 
      S     #Commission.Internal_error; 
      L     P##Data_fault; 
      L     #P_Job_bits; 
      -D    ; 
      +AR2  ; 
      S     DIX [AR2,P#0.0]; 
      L     0; 
      L     #Data_fault.Nr; 
      <>I   ; 
      O     #Intern.Trans_Para.Stop_fault_estimation; 
      JC    pa9; 
      L     #Job_fault_NR; 
      T     #Data_fault.Nr; 
      L     #Intern.Index_counter; 
      T     #Data_fault.Index; 
      L     #Intern.Parameter_Nr_actual; 
      T     #Data_fault.Parameter_Nr; 
      L     #Intern.Fault_DP_SFC14_15; 
      T     #Data_fault.DP_Add_info; 
      L     #Intern.Job_counter; 
      +     1; 
      T     #Data_fault.Request_Nr; 
// end of response
pa9:  L     0; 
      T     #PKW.SEND.Value; 
      T     #PKW.SEND.Identifier_Nr; 
      T     #PKW.SEND.Index; 
      S     #Intern.Job_end; 
      JU    pa1; 
pae:  NOP   0; 
NETWORK
TITLE =Drive Data Set selection
//*** ADDED BY STP ***
//
//01Oct18: (STP) Sinamics drives return data in different format. Properly 
//extract parameter and bit number. Changed booleans, as STW1.15 is no longer not 
//mapped for Sinamics drives as it was for MM4.
//
// The VFD must have been configured specifically for the use with different
// Drive Data Sets. We use two unused booleans in Control Word 1 (STW1):
// bit 13 (unused) and bit 14 (motorized potentiometer up/down).
//
// P820/821 format: PPPP-XXBB
//                  PPPP = higher order word with parameter number
//                  XX   = MM4: always 0; Sinamics: always 0xFC
//                  BB   = lower byte of lower order word containing bit number
// P0820 should be r2090.13 and P821 should be r2090.14
//
//    P0821        P0821
//    DDS bit 1    DDS bit 0    DDS#
//    ---------    ---------    -----
//        0            0        Drive Data Set 0
//        0            1        Drive Data Set 1
//        1            0        Drive Data Set 2
//    The changeover may take >=50 ms <=2500 ms
//
// Micromaster 4: check actual DDS wih r0051.1 and r0051.0
//   r0051.0   =    Selected DDS
//   r0051.1   =    Active DDS
// Sinamics: check actual DDS via r0837.1 and r837.0
// The instance data is preset for MM4, so for Sinmics, the value needs to
// be written before calling this FB:
//      L     837
//      T     DBx.Job_25.Parameter_Nr
//      L     0
//      T     DBx.Job_25.Index
//
// Drive Data Sets can be changed while running but not all parameters
// will switch (i.e. ramp times will, motor parameters will not). Only
// once the drive is not running with "drive ready" active, will all
// parameters switch.
//
// *** Important ***
// Several jobs are preconfigured here to retrieve motor configuration data,
// like rated current, rated RPM, etc. When switching DDS, the index for these
// parameters should reflect the active DDS.
//
// *** Important ***
// When changing the drive parameters for ramp times, ensure that the changes
// are made for all relevant Drive Data Sets, not just the default 0.
//
// -------------------------------------------------------------------------------
//--------
//
// Extract P0820 and P0821
//   Upper 16 bits represent parameter value
//   Lowest 8 bits represent the bit number
      L     #Job_23.Value; // Read P0820 value for DDS bit 0
      SRD   16; // Extract higher order word: 0xPPPPxxBB (P=Parm; B=bit)
      T     #DDS0_Parm; 

      L     #Job_23.Value; 
      AD    DW#16#FF; // Extract lowest byte: 0xPPPPxxBB (P=Parm; B=bit)
      T     #DDS0_Bit; 

      L     #Job_24.Value; // Read P0821 value for DDS bit 1
      SRD   16; // Extract higher order word: 0xPPPPxxBB (P=Parm; B=bit)
      T     #DDS1_Parm; 

      L     #Job_24.Value; 
      AD    DW#16#FF; // Extract lowest byte: 0xPPPPxxBB (P=Parm; B=bit)
      T     #DDS1_Bit; 


// Indicate that P0820 and P0821 have been configured properly to allow DDS switching

      A(    ; 
      L     #DDS0_Parm; 
      L     L#2090; 
      ==D   ; 
      )     ; 
      A(    ; 
      L     #DDS0_Bit; 
      L     L#13; 
      ==D   ; 
      )     ; 
      A(    ; 
      L     #DDS1_Parm; 
      L     L#2090; 
      ==D   ; 
      )     ; 
      A(    ; 
      L     #DDS1_Bit; 
      L     L#14; 
      ==D   ; 
      )     ; 
      =     #DDS.Parm_valid; // Drive parameter configuration valid



// Verify the supplied DDS nbr is valid (important when checking if the
// active DDS matches the requested DDS.
// MM4: always supports 0..3; Sinamics: in QC, set P180 to 3 (for 0..2)

      A(    ; 
      L     #DDS.Nr; 
      L     0; 
      >=I   ; 
      )     ; 
      A(    ; 
      L     #DDS.Nr; 
      L     2; 
      <=I   ; 
      )     ; 
      =     #DDS.Nr_valid; 


// DDS 0 requested, STW1.13 = 0; STW1.14 = 0

      L     #DDS.Nr; // Desired DDS = 0
      L     0; 
      ==I   ; 
//      A     #PCD_receive.Drive_ready    // Drive ready, not running
      A     #Drive_STOP; 
      A     #DDS.Parm_valid; // P0820/0821 configured properly
      R     #PCD_send.DDS_Bit_0; // Utilize unused bit 12 for DDS bit 0
      R     #PCD_send.DDS_Bit_1; // Utilize unused bit 15 for DDS bit 1


// DDS 1 requested, STW1.13 = 1; STW1.14 = 0

      L     #DDS.Nr; // Desired DDS = 1
      L     1; 
      ==I   ; 
//      A     #PCD_receive.Drive_ready    // Drive ready, not running
      A     #Drive_STOP; 
      A     #DDS.Parm_valid; // P0820/0821 configured properly
      S     #PCD_send.DDS_Bit_0; // Utilize unused bit 12 for DDS bit 0
      R     #PCD_send.DDS_Bit_1; // Utilize unused bit 15 for DDS bit 1


// DDS 2 requested, STW1.13 = 0; STW1.14 = 1

      L     #DDS.Nr; // Desired DDS = 2
      L     2; 
      ==I   ; 
//      A     #PCD_receive.Drive_ready    // Drive ready, not running
      A     #Drive_STOP; 
      A     #DDS.Parm_valid; // P0820/0821 configured properly
      R     #PCD_send.DDS_Bit_0; // Utilize unused bit 12 for DDS bit 0
      S     #PCD_send.DDS_Bit_1; // Utilize unused bit 15 for DDS bit 1


// For the Micromaster 420/440, read the actual DDS from r51.
// For the Sinamics G120, read from r837.

//   Write job 25 parameter nbr for Micromaster
//   1001 = MicroMaster 420
//   1002 = MicroMaster 440
//   1003 = Micro/combiMaster 411
//   1004 = MicroMaster 410
//   1005 = <reserved>
//   1006 = MicroMaster 440 Px
//   1007 = MicroMaster 430
      A(    ; 
      L     #Job_16.Type_1; 
      L     1001; 
      >=I   ; 
      )     ; 
      A(    ; 
      L     #Job_16.Type_1; 
      L     1007; 
      <=I   ; 
      )     ; 
      JNB   _007; 

// Configure reading active Drive Data Set

      L     51; 
      T     #Job_25.Parameter_Nr; 

// Configure reading active alarm

      L     2110; // Read r2110
      T     #Job_13.Parameter_Nr; 

      L     3; // read 4 codes
      T     #Job_13.Index; 

      L     B#16#11; // multiple
      T     #Job_13.Identifier; 

//    Write job 25 parameter for Sinamics G120
//    5700 --> Sinamics G120 Cu230P-2_DP
//    5701 --> Sinamics G120 Cu230P-2_PN
//    5702 --> Sinamics G120 Cu230P-2_CAN
//    5703 --> Sinamics G120 Cu230P-2_HVAC
//    5705 --> Sinamics G120 Cu230P-2_BT
//    6100 --> SINAMICS G120 CU240B-2_DP    
//    6103 --> SINAMICS G120 CU240B-2       
//    6210 --> SINAMICS G120 CU240E-2_DP    
//    6211 --> SINAMICS G120 CU240E-2_PN    
//    6213 --> SINAMICS G120 CU240E-2       
//    6220 --> SINAMICS G120 CU240E-2_DP_F  
//    6221 --> SINAMICS G120 CU240E-2_PN_F  
//    6223 --> SINAMICS G120 CU240E-2_F     
//    6363 --> SINAMICS G120 CU250S-2 VECTOR
//    6360 --> SINAMICS G120 CU250S-2_DP VECTOR
//    6361 --> SINAMICS G120 CU250S-2_PN VECTOR
//    6362 --> SINAMICS G120 CU250S-2_CAN VECTOR
_007: A(    ; 
      L     #Job_16.Type_1; 
      L     5700; 
      >=I   ; 
      )     ; 
      JNB   _008; 

// Configure reading active Drive Data Set

      L     837; 
      T     #Job_25.Parameter_Nr; 

// Configure reading active alarm

      L     2132; // Read r2132
      T     #Job_13.Parameter_Nr; 

      L     0; 
      T     #Job_13.Index; 

      L     B#16#1; 
      T     #Job_13.Identifier; 

_008: NOP   0; 


// If P820/821 are configured check if the drive has switched to the
// requested DDS. If P820/821 are not configured, ignore.
// This is used in the drive's enable signal. Specifying an invalid DDS
// could lead to unpredictable results so best to stop the motor.

      A     #DDS.Parm_valid; // [ P820/821 configured:
      A     #DDS.Nr_valid; // [ ..DDS nbr valid 0..2
      A(    ; // [ ..Actual DDS = requested DDS
      L     #Job_25.Value; // [
      L     #DDS.Nr; // [
      ITD   ; 
      ==D   ; 
      )     ; // P820/821 not configured
      ON    #DDS.Parm_valid; 
      =     #DDS.OK; 


// Alter job indices to match active Drive Data Set
// Some jobs are requesting DDS-specific data, so the parameter index must change
// with the active Drive Data Set. Job 25 returns the active DDS as DWORD, which 
// we copy to the job indices of several jobs.

      L     #Job_25.Value; // Active DDS nbr
      T     #Job_18.Index; // P0311: Rated motor RPM
      T     #Job_19.Index; // P0305: Rated motor current
      T     #Job_20.Index; // P2000: Reference frequency
      T     #Job_22.Index; // P0305: Rated motor frequency

NETWORK
TITLE =Call SFC15 for write

      A     #Intern.Fault_DP_PCD_access; 
      JC    Na0a; 

      LAR1  P##PCD_send; 
      L     DID [AR1,P#0.0]; 
      LAR1  #PCD_Address; 
      T     PQD [AR1,P#8.0]; 

      AN    #Intern.Job_an; 
      AN    #Intern.Job_end; 
      BEC   ; 
      R     #Intern.Job_end; 

Na0a: CALL SFC   15 (// call SFC15 (write to output peripheral addresses)
           LADDR                    := #P_Address,
           RECORD                   := #PKW.SEND,
           RET_VAL                  := #Intern.Fault_DP_SFC14_15);

NETWORK
TITLE =COPY PARAMETER VALUES TO BLOCK OUTPUTS
//*** ADDED BY STP ***
//
//Copy values from jobs 1..3 to block outputs.
//
//Could calculate actual output frequency as:
//
//(Job_22.Rater_motor_frequency * Speed) / 100.0
// ----------------------------------------------------------------------------
// Copy motor current
// ----------------------------------------------------------------------------
      L     0.000000e+000; 
      T     #Current; 

      A     #Data_fault.JOB.RW_Request_1; //return 0 on data r/w error
      JC    _14a; 
      L     #Job_1.Motor_current; //copy value from drive
      T     #Current; 


// ----------------------------------------------------------------------------
// Copy motor torque
// ----------------------------------------------------------------------------

_14a: L     0.000000e+000; 
      T     #Torque; 

      A     #Data_fault.JOB.RW_Request_2; //return 0 on data r/w error
      JC    _14b; 
      L     #Job_2.Motor_torque; //copy value from drive
      ABS   ; 
      T     #Torque; 


// ----------------------------------------------------------------------------
// Copy motor RPM
// ----------------------------------------------------------------------------

_14b: L     0.000000e+000; 
      T     #RPM; 

      A     #Data_fault.JOB.R_Request_17; //return 0 on data r/w error
      JC    _14c; 
      L     #Job_17.Motor_RPM; 
      ABS   ; 
      T     #RPM; 


// ----------------------------------------------------------------------------
// Copy motor frequency
// ----------------------------------------------------------------------------

_14c: L     0.000000e+000; 
      T     #Frequency; 

      A     #Data_fault.JOB.R_Request_26; //return 0 on data r/w error
      JC    _14d; 
      L     #Job_26.Motor_frq; 
      ABS   ; 
      T     #Frequency; 

_14d: NOP   0; 

NETWORK
TITLE =COPY DIAG CODE TO BLOCK OUTPUTS
//Send the alarm or fault code to WinCC for visual feedback.
      A(    ; 
      L     #Job_13.Last_warning_1; 
      T     #Diag_code; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
      A     BR; 
      )     ; 
      A(    ; 
      L     #Job_14.Last_fault_1; 
      L     L#0; 
      >I    ; 
      )     ; 
      JNB   _009; 
      L     #Job_14.Last_fault_1; 
      T     #Diag_code; 
_009: NOP   0; 
END_FUNCTION_BLOCK

